// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module pcie_config_reg (
        input wire clk,
        input wire rst,

        output logic s_axil_awready,
        input wire s_axil_awvalid,
        input wire [8:0] s_axil_awaddr,
        input wire [2:0] s_axil_awprot,
        output logic s_axil_wready,
        input wire s_axil_wvalid,
        input wire [31:0] s_axil_wdata,
        input wire [3:0]s_axil_wstrb,
        input wire s_axil_bready,
        output logic s_axil_bvalid,
        output logic [1:0] s_axil_bresp,
        output logic s_axil_arready,
        input wire s_axil_arvalid,
        input wire [8:0] s_axil_araddr,
        input wire [2:0] s_axil_arprot,
        input wire s_axil_rready,
        output logic s_axil_rvalid,
        output logic [31:0] s_axil_rdata,
        output logic [1:0] s_axil_rresp,

        input pcie_config_reg_pkg::pcie_config_reg__in_t hwif_in,
        output pcie_config_reg_pkg::pcie_config_reg__out_t hwif_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [8:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    // Max Outstanding Transactions: 2
    logic [1:0] axil_n_in_flight;
    logic axil_prev_was_rd;
    logic axil_arvalid;
    logic [8:0] axil_araddr;
    logic axil_ar_accept;
    logic axil_awvalid;
    logic [8:0] axil_awaddr;
    logic axil_wvalid;
    logic [31:0] axil_wdata;
    logic [3:0] axil_wstrb;
    logic axil_aw_accept;
    logic axil_resp_acked;

    // Transaction request acceptance
    always_ff @(posedge clk) begin
        if(rst) begin
            axil_prev_was_rd <= '0;
            axil_arvalid <= '0;
            axil_araddr <= '0;
            axil_awvalid <= '0;
            axil_awaddr <= '0;
            axil_wvalid <= '0;
            axil_wdata <= '0;
            axil_wstrb <= '0;
            axil_n_in_flight <= '0;
        end else begin
            // AR* acceptance register
            if(axil_ar_accept) begin
                axil_prev_was_rd <= '1;
                axil_arvalid <= '0;
            end
            if(s_axil_arvalid && s_axil_arready) begin
                axil_arvalid <= '1;
                axil_araddr <= s_axil_araddr;
            end

            // AW* & W* acceptance registers
            if(axil_aw_accept) begin
                axil_prev_was_rd <= '0;
                axil_awvalid <= '0;
                axil_wvalid <= '0;
            end
            if(s_axil_awvalid && s_axil_awready) begin
                axil_awvalid <= '1;
                axil_awaddr <= s_axil_awaddr;
            end
            if(s_axil_wvalid && s_axil_wready) begin
                axil_wvalid <= '1;
                axil_wdata <= s_axil_wdata;
                axil_wstrb <= s_axil_wstrb;
            end

            // Keep track of in-flight transactions
            if((axil_ar_accept || axil_aw_accept) && !axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight + 1'b1;
            end else if(!(axil_ar_accept || axil_aw_accept) && axil_resp_acked) begin
                axil_n_in_flight <= axil_n_in_flight - 1'b1;
            end
        end
    end

    always_comb begin
        s_axil_arready = (!axil_arvalid || axil_ar_accept);
        s_axil_awready = (!axil_awvalid || axil_aw_accept);
        s_axil_wready = (!axil_wvalid || axil_aw_accept);
    end

    // Request dispatch
    always_comb begin
        cpuif_wr_data = axil_wdata;
        for(int i=0; i<4; i++) begin
            cpuif_wr_biten[i*8 +: 8] = {8{axil_wstrb[i]}};
        end
        cpuif_req = '0;
        cpuif_req_is_wr = '0;
        cpuif_addr = '0;
        axil_ar_accept = '0;
        axil_aw_accept = '0;

        if(axil_n_in_flight < 2'd2) begin
            // Can safely issue more transactions without overwhelming response buffer
            if(axil_arvalid && !axil_prev_was_rd) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[8:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end else if(axil_awvalid && axil_wvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '1;
                cpuif_addr = {axil_awaddr[8:2], 2'b0};
                if(!cpuif_req_stall_wr) axil_aw_accept = '1;
            end else if(axil_arvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axil_araddr[8:2], 2'b0};
                if(!cpuif_req_stall_rd) axil_ar_accept = '1;
            end
        end
    end


    // AXI4-Lite Response Logic
    struct {
        logic is_wr;
        logic err;
        logic [31:0] rdata;
    } axil_resp_buffer[2];

    logic [1:0] axil_resp_wptr;
    logic [1:0] axil_resp_rptr;

    always_ff @(posedge clk) begin
        if(rst) begin
            for(int i=0; i<2; i++) begin
                axil_resp_buffer[i].is_wr <= '0;
                axil_resp_buffer[i].err <= '0;
                axil_resp_buffer[i].rdata <= '0;
            end
            axil_resp_wptr <= '0;
            axil_resp_rptr <= '0;
        end else begin
            // Store responses in buffer until AXI response channel accepts them
            if(cpuif_rd_ack || cpuif_wr_ack) begin
                if(cpuif_rd_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '0;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_rd_err;
                    axil_resp_buffer[axil_resp_wptr[0:0]].rdata <= cpuif_rd_data;

                end else if(cpuif_wr_ack) begin
                    axil_resp_buffer[axil_resp_wptr[0:0]].is_wr <= '1;
                    axil_resp_buffer[axil_resp_wptr[0:0]].err <= cpuif_wr_err;
                end
                axil_resp_wptr <= axil_resp_wptr + 1'b1;
            end

            // Advance read pointer when acknowledged
            if(axil_resp_acked) begin
                axil_resp_rptr <= axil_resp_rptr + 1'b1;
            end
        end
    end

    always_comb begin
        axil_resp_acked = '0;
        s_axil_bvalid = '0;
        s_axil_rvalid = '0;
        if(axil_resp_rptr != axil_resp_wptr) begin
            if(axil_resp_buffer[axil_resp_rptr[0:0]].is_wr) begin
                s_axil_bvalid = '1;
                if(s_axil_bready) axil_resp_acked = '1;
            end else begin
                s_axil_rvalid = '1;
                if(s_axil_rready) axil_resp_acked = '1;
            end
        end

        s_axil_rdata = axil_resp_buffer[axil_resp_rptr[0:0]].rdata;
        if(axil_resp_buffer[axil_resp_rptr[0:0]].err) begin
            s_axil_bresp = 2'b10;
            s_axil_rresp = 2'b10;
        end else begin
            s_axil_bresp = 2'b00;
            s_axil_rresp = 2'b00;
        end
    end

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic byte_offset_00;
        logic byte_offset_04;
        logic byte_offset_08;
        logic byte_offset_0C;
        logic base_address_register_0;
        logic base_ddress_register_1;
        logic base_ddress_register_2;
        logic base_ddress_register_3;
        logic base_ddress_register_4;
        logic base_ddress_register_5;
        logic cardbus_cis_pointer;
        logic byte_offset_2C;
        logic capabilities_pointer;
        logic byte_offset_3C;
        logic capabilities_power_mngt_pointer;
        logic power_management_pointer;
        logic capabilities_power_na_pointer;
        logic link_control_3_register;
        logic lane_error_status_register;
        logic lane_eq_ctrl_register;
        logic extended_capabilities;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        decoded_reg_strb.byte_offset_00 = cpuif_req_masked & (cpuif_addr == 9'h0);
        decoded_reg_strb.byte_offset_04 = cpuif_req_masked & (cpuif_addr == 9'h4);
        decoded_reg_strb.byte_offset_08 = cpuif_req_masked & (cpuif_addr == 9'h8);
        decoded_reg_strb.byte_offset_0C = cpuif_req_masked & (cpuif_addr == 9'hc);
        decoded_reg_strb.base_address_register_0 = cpuif_req_masked & (cpuif_addr == 9'h10);
        decoded_reg_strb.base_ddress_register_1 = cpuif_req_masked & (cpuif_addr == 9'h14);
        decoded_reg_strb.base_ddress_register_2 = cpuif_req_masked & (cpuif_addr == 9'h18);
        decoded_reg_strb.base_ddress_register_3 = cpuif_req_masked & (cpuif_addr == 9'h1c);
        decoded_reg_strb.base_ddress_register_4 = cpuif_req_masked & (cpuif_addr == 9'h20);
        decoded_reg_strb.base_ddress_register_5 = cpuif_req_masked & (cpuif_addr == 9'h24);
        decoded_reg_strb.cardbus_cis_pointer = cpuif_req_masked & (cpuif_addr == 9'h28);
        decoded_reg_strb.byte_offset_2C = cpuif_req_masked & (cpuif_addr == 9'h2c);
        decoded_reg_strb.capabilities_pointer = cpuif_req_masked & (cpuif_addr == 9'h34);
        decoded_reg_strb.byte_offset_3C = cpuif_req_masked & (cpuif_addr == 9'h3c);
        decoded_reg_strb.capabilities_power_mngt_pointer = cpuif_req_masked & (cpuif_addr == 9'h40);
        decoded_reg_strb.power_management_pointer = cpuif_req_masked & (cpuif_addr == 9'h44);
        decoded_reg_strb.capabilities_power_na_pointer = cpuif_req_masked & (cpuif_addr == 9'h48);
        decoded_reg_strb.link_control_3_register = cpuif_req_masked & (cpuif_addr == 9'h4c);
        decoded_reg_strb.lane_error_status_register = cpuif_req_masked & (cpuif_addr == 9'h50);
        decoded_reg_strb.lane_eq_ctrl_register = cpuif_req_masked & (cpuif_addr == 9'h54);
        decoded_reg_strb.extended_capabilities = cpuif_req_masked & (cpuif_addr == 9'h100);
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic next;
                logic load_next;
            } bus_master_enable;
            struct {
                logic next;
                logic load_next;
            } special_cycle_enable;
            struct {
                logic next;
                logic load_next;
            } memory_write_invalidate;
            struct {
                logic next;
                logic load_next;
            } vga_palette_snoop;
            struct {
                logic next;
                logic load_next;
            } parity_error_response;
            struct {
                logic next;
                logic load_next;
            } idsel_step_wait_cycle_control;
            struct {
                logic next;
                logic load_next;
            } SERR_Enable;
            struct {
                logic next;
                logic load_next;
            } fast_b2b_transactions_enable;
            struct {
                logic next;
                logic load_next;
            } interrupt_disable;
            struct {
                logic [7:0] next;
                logic load_next;
            } rsvd;
            struct {
                logic next;
                logic load_next;
            } interrupt_status;
            struct {
                logic next;
                logic load_next;
            } capabilities_list;
            struct {
                logic next;
                logic load_next;
            } sixtysix_mhz_capable;
            struct {
                logic next;
                logic load_next;
            } fast_b2b_transactions_capable;
            struct {
                logic next;
                logic load_next;
            } master_data_parity_error;
            struct {
                logic [1:0] next;
                logic load_next;
            } devsel_timing;
            struct {
                logic next;
                logic load_next;
            } signaled_target_abort;
            struct {
                logic next;
                logic load_next;
            } received_target_abort;
            struct {
                logic next;
                logic load_next;
            } received_master_abort;
            struct {
                logic next;
                logic load_next;
            } signaled_system_error;
            struct {
                logic next;
                logic load_next;
            } detected_parity_error;
        } byte_offset_04;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } cache_line_size_register;
            struct {
                logic [7:0] next;
                logic load_next;
            } latency_timer_register;
            struct {
                logic [7:0] next;
                logic load_next;
            } interrupt_line_register;
            struct {
                logic [7:0] next;
                logic load_next;
            } interrupt_pin_register;
        } byte_offset_0C;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } BAR;
        } base_ddress_register_2;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } BAR;
        } base_ddress_register_3;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } BAR;
        } base_ddress_register_4;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } BAR;
        } base_ddress_register_5;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } word;
        } cardbus_cis_pointer;
        struct {
            struct {
                logic [7:0] next;
                logic load_next;
            } interrupt_line;
            struct {
                logic [7:0] next;
                logic load_next;
            } interrupt_pin;
        } byte_offset_3C;
        struct {
            struct {
                logic [2:0] next;
                logic load_next;
            } version;
            struct {
                logic next;
                logic load_next;
            } pme_clock;
            struct {
                logic next;
                logic load_next;
            } dev_spec_init;
            struct {
                logic [2:0] next;
                logic load_next;
            } aux_current;
            struct {
                logic next;
                logic load_next;
            } d1_support;
            struct {
                logic next;
                logic load_next;
            } d2_support;
            struct {
                logic [4:0] next;
                logic load_next;
            } pme_support;
        } capabilities_power_mngt_pointer;
        struct {
            struct {
                logic [1:0] next;
                logic load_next;
            } power_state;
            struct {
                logic next;
                logic load_next;
            } pme_enable;
            struct {
                logic [3:0] next;
                logic load_next;
            } data_select;
            struct {
                logic [1:0] next;
                logic load_next;
            } data_scale;
            struct {
                logic next;
                logic load_next;
            } pme_status;
            struct {
                logic next;
                logic load_next;
            } b2_b3_support;
            struct {
                logic next;
                logic load_next;
            } bus_pwr_clk_ctrl_en;
            struct {
                logic [7:0] next;
                logic load_next;
            } data;
        } power_management_pointer;
        struct {
            struct {
                logic next;
                logic load_next;
            } perform_equalization;
            struct {
                logic next;
                logic load_next;
            } link_eq_req_intr_en;
        } link_control_3_register;
        struct {
            struct {
                logic [4:0] next;
                logic load_next;
            } lane_error;
        } lane_error_status_register;
        struct {
            struct {
                logic [3:0] next;
                logic load_next;
            } downstream_tx_preset;
            struct {
                logic [2:0] next;
                logic load_next;
            } downstream_rx_preset_hint;
            struct {
                logic [3:0] next;
                logic load_next;
            } upstream_tx_preset;
            struct {
                logic [2:0] next;
                logic load_next;
            } upstream_rx_preset_hint;
        } lane_eq_ctrl_register;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic value;
            } bus_master_enable;
            struct {
                logic value;
            } special_cycle_enable;
            struct {
                logic value;
            } memory_write_invalidate;
            struct {
                logic value;
            } vga_palette_snoop;
            struct {
                logic value;
            } parity_error_response;
            struct {
                logic value;
            } idsel_step_wait_cycle_control;
            struct {
                logic value;
            } SERR_Enable;
            struct {
                logic value;
            } fast_b2b_transactions_enable;
            struct {
                logic value;
            } interrupt_disable;
            struct {
                logic [7:0] value;
            } rsvd;
            struct {
                logic value;
            } interrupt_status;
            struct {
                logic value;
            } capabilities_list;
            struct {
                logic value;
            } sixtysix_mhz_capable;
            struct {
                logic value;
            } fast_b2b_transactions_capable;
            struct {
                logic value;
            } master_data_parity_error;
            struct {
                logic [1:0] value;
            } devsel_timing;
            struct {
                logic value;
            } signaled_target_abort;
            struct {
                logic value;
            } received_target_abort;
            struct {
                logic value;
            } received_master_abort;
            struct {
                logic value;
            } signaled_system_error;
            struct {
                logic value;
            } detected_parity_error;
        } byte_offset_04;
        struct {
            struct {
                logic [7:0] value;
            } cache_line_size_register;
            struct {
                logic [7:0] value;
            } latency_timer_register;
            struct {
                logic [7:0] value;
            } interrupt_line_register;
            struct {
                logic [7:0] value;
            } interrupt_pin_register;
        } byte_offset_0C;
        struct {
            struct {
                logic [31:0] value;
            } BAR;
        } base_ddress_register_2;
        struct {
            struct {
                logic [31:0] value;
            } BAR;
        } base_ddress_register_3;
        struct {
            struct {
                logic [31:0] value;
            } BAR;
        } base_ddress_register_4;
        struct {
            struct {
                logic [31:0] value;
            } BAR;
        } base_ddress_register_5;
        struct {
            struct {
                logic [31:0] value;
            } word;
        } cardbus_cis_pointer;
        struct {
            struct {
                logic [7:0] value;
            } interrupt_line;
            struct {
                logic [7:0] value;
            } interrupt_pin;
        } byte_offset_3C;
        struct {
            struct {
                logic [2:0] value;
            } version;
            struct {
                logic value;
            } pme_clock;
            struct {
                logic value;
            } dev_spec_init;
            struct {
                logic [2:0] value;
            } aux_current;
            struct {
                logic value;
            } d1_support;
            struct {
                logic value;
            } d2_support;
            struct {
                logic [4:0] value;
            } pme_support;
        } capabilities_power_mngt_pointer;
        struct {
            struct {
                logic [1:0] value;
            } power_state;
            struct {
                logic value;
            } pme_enable;
            struct {
                logic [3:0] value;
            } data_select;
            struct {
                logic [1:0] value;
            } data_scale;
            struct {
                logic value;
            } pme_status;
            struct {
                logic value;
            } b2_b3_support;
            struct {
                logic value;
            } bus_pwr_clk_ctrl_en;
            struct {
                logic [7:0] value;
            } data;
        } power_management_pointer;
        struct {
            struct {
                logic value;
            } perform_equalization;
            struct {
                logic value;
            } link_eq_req_intr_en;
        } link_control_3_register;
        struct {
            struct {
                logic [4:0] value;
            } lane_error;
        } lane_error_status_register;
        struct {
            struct {
                logic [3:0] value;
            } downstream_tx_preset;
            struct {
                logic [2:0] value;
            } downstream_rx_preset_hint;
            struct {
                logic [3:0] value;
            } upstream_tx_preset;
            struct {
                logic [2:0] value;
            } upstream_rx_preset_hint;
        } lane_eq_ctrl_register;
    } field_storage_t;
    field_storage_t field_storage;

    assign hwif_out.byte_offset_00.Vendor_ID.value = 16'h1234;
    assign hwif_out.byte_offset_00.Device_ID.value = 16'hff;
    // Field: pcie_config_reg.byte_offset_04.bus_master_enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.bus_master_enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.bus_master_enable.value & ~decoded_wr_biten[2:2]) | (decoded_wr_data[2:2] & decoded_wr_biten[2:2]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.bus_master_enable.next = next_c;
        field_combo.byte_offset_04.bus_master_enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.bus_master_enable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.bus_master_enable.load_next) begin
                field_storage.byte_offset_04.bus_master_enable.value <= field_combo.byte_offset_04.bus_master_enable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.bus_master_enable.value = field_storage.byte_offset_04.bus_master_enable.value;
    // Field: pcie_config_reg.byte_offset_04.special_cycle_enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.special_cycle_enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.special_cycle_enable.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.special_cycle_enable.next = next_c;
        field_combo.byte_offset_04.special_cycle_enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.special_cycle_enable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.special_cycle_enable.load_next) begin
                field_storage.byte_offset_04.special_cycle_enable.value <= field_combo.byte_offset_04.special_cycle_enable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.special_cycle_enable.value = field_storage.byte_offset_04.special_cycle_enable.value;
    // Field: pcie_config_reg.byte_offset_04.memory_write_invalidate
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.memory_write_invalidate.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.memory_write_invalidate.value & ~decoded_wr_biten[4:4]) | (decoded_wr_data[4:4] & decoded_wr_biten[4:4]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.memory_write_invalidate.next = next_c;
        field_combo.byte_offset_04.memory_write_invalidate.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.memory_write_invalidate.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.memory_write_invalidate.load_next) begin
                field_storage.byte_offset_04.memory_write_invalidate.value <= field_combo.byte_offset_04.memory_write_invalidate.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.memory_write_invalidate.value = field_storage.byte_offset_04.memory_write_invalidate.value;
    // Field: pcie_config_reg.byte_offset_04.vga_palette_snoop
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.vga_palette_snoop.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.vga_palette_snoop.value & ~decoded_wr_biten[5:5]) | (decoded_wr_data[5:5] & decoded_wr_biten[5:5]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.vga_palette_snoop.next = next_c;
        field_combo.byte_offset_04.vga_palette_snoop.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.vga_palette_snoop.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.vga_palette_snoop.load_next) begin
                field_storage.byte_offset_04.vga_palette_snoop.value <= field_combo.byte_offset_04.vga_palette_snoop.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.vga_palette_snoop.value = field_storage.byte_offset_04.vga_palette_snoop.value;
    // Field: pcie_config_reg.byte_offset_04.parity_error_response
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.parity_error_response.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.parity_error_response.value & ~decoded_wr_biten[6:6]) | (decoded_wr_data[6:6] & decoded_wr_biten[6:6]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.parity_error_response.next = next_c;
        field_combo.byte_offset_04.parity_error_response.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.parity_error_response.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.parity_error_response.load_next) begin
                field_storage.byte_offset_04.parity_error_response.value <= field_combo.byte_offset_04.parity_error_response.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.parity_error_response.value = field_storage.byte_offset_04.parity_error_response.value;
    // Field: pcie_config_reg.byte_offset_04.idsel_step_wait_cycle_control
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.idsel_step_wait_cycle_control.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.idsel_step_wait_cycle_control.value & ~decoded_wr_biten[7:7]) | (decoded_wr_data[7:7] & decoded_wr_biten[7:7]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.idsel_step_wait_cycle_control.next = next_c;
        field_combo.byte_offset_04.idsel_step_wait_cycle_control.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.idsel_step_wait_cycle_control.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.idsel_step_wait_cycle_control.load_next) begin
                field_storage.byte_offset_04.idsel_step_wait_cycle_control.value <= field_combo.byte_offset_04.idsel_step_wait_cycle_control.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.idsel_step_wait_cycle_control.value = field_storage.byte_offset_04.idsel_step_wait_cycle_control.value;
    // Field: pcie_config_reg.byte_offset_04.SERR_Enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.SERR_Enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.SERR_Enable.value & ~decoded_wr_biten[8:8]) | (decoded_wr_data[8:8] & decoded_wr_biten[8:8]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.SERR_Enable.next = next_c;
        field_combo.byte_offset_04.SERR_Enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.SERR_Enable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.SERR_Enable.load_next) begin
                field_storage.byte_offset_04.SERR_Enable.value <= field_combo.byte_offset_04.SERR_Enable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.SERR_Enable.value = field_storage.byte_offset_04.SERR_Enable.value;
    // Field: pcie_config_reg.byte_offset_04.fast_b2b_transactions_enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.fast_b2b_transactions_enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.fast_b2b_transactions_enable.value & ~decoded_wr_biten[9:9]) | (decoded_wr_data[9:9] & decoded_wr_biten[9:9]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.fast_b2b_transactions_enable.next = next_c;
        field_combo.byte_offset_04.fast_b2b_transactions_enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.fast_b2b_transactions_enable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.fast_b2b_transactions_enable.load_next) begin
                field_storage.byte_offset_04.fast_b2b_transactions_enable.value <= field_combo.byte_offset_04.fast_b2b_transactions_enable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.fast_b2b_transactions_enable.value = field_storage.byte_offset_04.fast_b2b_transactions_enable.value;
    // Field: pcie_config_reg.byte_offset_04.interrupt_disable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.interrupt_disable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.interrupt_disable.value & ~decoded_wr_biten[10:10]) | (decoded_wr_data[10:10] & decoded_wr_biten[10:10]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.interrupt_disable.next = next_c;
        field_combo.byte_offset_04.interrupt_disable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.interrupt_disable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.interrupt_disable.load_next) begin
                field_storage.byte_offset_04.interrupt_disable.value <= field_combo.byte_offset_04.interrupt_disable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.interrupt_disable.value = field_storage.byte_offset_04.interrupt_disable.value;
    // Field: pcie_config_reg.byte_offset_04.rsvd
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.rsvd.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.rsvd.value & ~decoded_wr_biten[18:11]) | (decoded_wr_data[18:11] & decoded_wr_biten[18:11]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.rsvd.next = next_c;
        field_combo.byte_offset_04.rsvd.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.byte_offset_04.rsvd.load_next) begin
            field_storage.byte_offset_04.rsvd.value <= field_combo.byte_offset_04.rsvd.next;
        end
    end
    assign hwif_out.byte_offset_04.rsvd.value = field_storage.byte_offset_04.rsvd.value;
    // Field: pcie_config_reg.byte_offset_04.interrupt_status
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.interrupt_status.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.interrupt_status.value & ~decoded_wr_biten[19:19]) | (decoded_wr_data[19:19] & decoded_wr_biten[19:19]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.interrupt_status.next = next_c;
        field_combo.byte_offset_04.interrupt_status.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.interrupt_status.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.interrupt_status.load_next) begin
                field_storage.byte_offset_04.interrupt_status.value <= field_combo.byte_offset_04.interrupt_status.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.interrupt_status.value = field_storage.byte_offset_04.interrupt_status.value;
    // Field: pcie_config_reg.byte_offset_04.capabilities_list
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.capabilities_list.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.capabilities_list.value & ~decoded_wr_biten[20:20]) | (decoded_wr_data[20:20] & decoded_wr_biten[20:20]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.capabilities_list.next = next_c;
        field_combo.byte_offset_04.capabilities_list.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.capabilities_list.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.capabilities_list.load_next) begin
                field_storage.byte_offset_04.capabilities_list.value <= field_combo.byte_offset_04.capabilities_list.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.capabilities_list.value = field_storage.byte_offset_04.capabilities_list.value;
    // Field: pcie_config_reg.byte_offset_04.sixtysix_mhz_capable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.sixtysix_mhz_capable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.sixtysix_mhz_capable.value & ~decoded_wr_biten[21:21]) | (decoded_wr_data[21:21] & decoded_wr_biten[21:21]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.sixtysix_mhz_capable.next = next_c;
        field_combo.byte_offset_04.sixtysix_mhz_capable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.sixtysix_mhz_capable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.sixtysix_mhz_capable.load_next) begin
                field_storage.byte_offset_04.sixtysix_mhz_capable.value <= field_combo.byte_offset_04.sixtysix_mhz_capable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.sixtysix_mhz_capable.value = field_storage.byte_offset_04.sixtysix_mhz_capable.value;
    // Field: pcie_config_reg.byte_offset_04.fast_b2b_transactions_capable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.fast_b2b_transactions_capable.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.fast_b2b_transactions_capable.value & ~decoded_wr_biten[23:23]) | (decoded_wr_data[23:23] & decoded_wr_biten[23:23]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.fast_b2b_transactions_capable.next = next_c;
        field_combo.byte_offset_04.fast_b2b_transactions_capable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.fast_b2b_transactions_capable.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.fast_b2b_transactions_capable.load_next) begin
                field_storage.byte_offset_04.fast_b2b_transactions_capable.value <= field_combo.byte_offset_04.fast_b2b_transactions_capable.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.fast_b2b_transactions_capable.value = field_storage.byte_offset_04.fast_b2b_transactions_capable.value;
    // Field: pcie_config_reg.byte_offset_04.master_data_parity_error
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.master_data_parity_error.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.master_data_parity_error.value & ~decoded_wr_biten[24:24]) | (decoded_wr_data[24:24] & decoded_wr_biten[24:24]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.master_data_parity_error.next = next_c;
        field_combo.byte_offset_04.master_data_parity_error.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.master_data_parity_error.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.master_data_parity_error.load_next) begin
                field_storage.byte_offset_04.master_data_parity_error.value <= field_combo.byte_offset_04.master_data_parity_error.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.master_data_parity_error.value = field_storage.byte_offset_04.master_data_parity_error.value;
    // Field: pcie_config_reg.byte_offset_04.devsel_timing
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.devsel_timing.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.devsel_timing.value & ~decoded_wr_biten[26:25]) | (decoded_wr_data[26:25] & decoded_wr_biten[26:25]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.devsel_timing.next = next_c;
        field_combo.byte_offset_04.devsel_timing.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.devsel_timing.value <= 2'h0;
        end else begin
            if(field_combo.byte_offset_04.devsel_timing.load_next) begin
                field_storage.byte_offset_04.devsel_timing.value <= field_combo.byte_offset_04.devsel_timing.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.devsel_timing.value = field_storage.byte_offset_04.devsel_timing.value;
    // Field: pcie_config_reg.byte_offset_04.signaled_target_abort
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.signaled_target_abort.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.signaled_target_abort.value & ~decoded_wr_biten[27:27]) | (decoded_wr_data[27:27] & decoded_wr_biten[27:27]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.signaled_target_abort.next = next_c;
        field_combo.byte_offset_04.signaled_target_abort.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.signaled_target_abort.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.signaled_target_abort.load_next) begin
                field_storage.byte_offset_04.signaled_target_abort.value <= field_combo.byte_offset_04.signaled_target_abort.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.signaled_target_abort.value = field_storage.byte_offset_04.signaled_target_abort.value;
    // Field: pcie_config_reg.byte_offset_04.received_target_abort
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.received_target_abort.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.received_target_abort.value & ~decoded_wr_biten[28:28]) | (decoded_wr_data[28:28] & decoded_wr_biten[28:28]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.received_target_abort.next = next_c;
        field_combo.byte_offset_04.received_target_abort.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.received_target_abort.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.received_target_abort.load_next) begin
                field_storage.byte_offset_04.received_target_abort.value <= field_combo.byte_offset_04.received_target_abort.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.received_target_abort.value = field_storage.byte_offset_04.received_target_abort.value;
    // Field: pcie_config_reg.byte_offset_04.received_master_abort
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.received_master_abort.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.received_master_abort.value & ~decoded_wr_biten[29:29]) | (decoded_wr_data[29:29] & decoded_wr_biten[29:29]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.received_master_abort.next = next_c;
        field_combo.byte_offset_04.received_master_abort.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.received_master_abort.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.received_master_abort.load_next) begin
                field_storage.byte_offset_04.received_master_abort.value <= field_combo.byte_offset_04.received_master_abort.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.received_master_abort.value = field_storage.byte_offset_04.received_master_abort.value;
    // Field: pcie_config_reg.byte_offset_04.signaled_system_error
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.signaled_system_error.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.signaled_system_error.value & ~decoded_wr_biten[30:30]) | (decoded_wr_data[30:30] & decoded_wr_biten[30:30]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.signaled_system_error.next = next_c;
        field_combo.byte_offset_04.signaled_system_error.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.signaled_system_error.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.signaled_system_error.load_next) begin
                field_storage.byte_offset_04.signaled_system_error.value <= field_combo.byte_offset_04.signaled_system_error.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.signaled_system_error.value = field_storage.byte_offset_04.signaled_system_error.value;
    // Field: pcie_config_reg.byte_offset_04.detected_parity_error
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_04.detected_parity_error.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_04 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_04.detected_parity_error.value & ~decoded_wr_biten[31:31]) | (decoded_wr_data[31:31] & decoded_wr_biten[31:31]);
            load_next_c = '1;
        end
        field_combo.byte_offset_04.detected_parity_error.next = next_c;
        field_combo.byte_offset_04.detected_parity_error.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_04.detected_parity_error.value <= 1'h0;
        end else begin
            if(field_combo.byte_offset_04.detected_parity_error.load_next) begin
                field_storage.byte_offset_04.detected_parity_error.value <= field_combo.byte_offset_04.detected_parity_error.next;
            end
        end
    end
    assign hwif_out.byte_offset_04.detected_parity_error.value = field_storage.byte_offset_04.detected_parity_error.value;
    assign hwif_out.byte_offset_08.Revision_ID.value = 8'h0;
    assign hwif_out.byte_offset_08.Class_Code.value = 24'h0;
    // Field: pcie_config_reg.byte_offset_0C.cache_line_size_register
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_0C.cache_line_size_register.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_0C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_0C.cache_line_size_register.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_0C.cache_line_size_register.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_0C.cache_line_size_register.next = next_c;
        field_combo.byte_offset_0C.cache_line_size_register.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.byte_offset_0C.cache_line_size_register.load_next) begin
            field_storage.byte_offset_0C.cache_line_size_register.value <= field_combo.byte_offset_0C.cache_line_size_register.next;
        end
    end
    assign hwif_out.byte_offset_0C.cache_line_size_register.value = field_storage.byte_offset_0C.cache_line_size_register.value;
    // Field: pcie_config_reg.byte_offset_0C.latency_timer_register
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_0C.latency_timer_register.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_0C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_0C.latency_timer_register.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_0C.latency_timer_register.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_0C.latency_timer_register.next = next_c;
        field_combo.byte_offset_0C.latency_timer_register.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.byte_offset_0C.latency_timer_register.load_next) begin
            field_storage.byte_offset_0C.latency_timer_register.value <= field_combo.byte_offset_0C.latency_timer_register.next;
        end
    end
    assign hwif_out.byte_offset_0C.latency_timer_register.value = field_storage.byte_offset_0C.latency_timer_register.value;
    // Field: pcie_config_reg.byte_offset_0C.interrupt_line_register
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_0C.interrupt_line_register.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_0C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_0C.interrupt_line_register.value & ~decoded_wr_biten[23:16]) | (decoded_wr_data[23:16] & decoded_wr_biten[23:16]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_0C.interrupt_line_register.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_0C.interrupt_line_register.next = next_c;
        field_combo.byte_offset_0C.interrupt_line_register.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.byte_offset_0C.interrupt_line_register.load_next) begin
            field_storage.byte_offset_0C.interrupt_line_register.value <= field_combo.byte_offset_0C.interrupt_line_register.next;
        end
    end
    assign hwif_out.byte_offset_0C.interrupt_line_register.value = field_storage.byte_offset_0C.interrupt_line_register.value;
    // Field: pcie_config_reg.byte_offset_0C.interrupt_pin_register
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_0C.interrupt_pin_register.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_0C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_0C.interrupt_pin_register.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_0C.interrupt_pin_register.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_0C.interrupt_pin_register.next = next_c;
        field_combo.byte_offset_0C.interrupt_pin_register.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.byte_offset_0C.interrupt_pin_register.load_next) begin
            field_storage.byte_offset_0C.interrupt_pin_register.value <= field_combo.byte_offset_0C.interrupt_pin_register.next;
        end
    end
    assign hwif_out.byte_offset_0C.interrupt_pin_register.value = field_storage.byte_offset_0C.interrupt_pin_register.value;
    assign hwif_out.base_address_register_0.region_type.value = 1'h0;
    assign hwif_out.base_address_register_0.locatable.value = 2'h0;
    assign hwif_out.base_address_register_0.prefetchable.value = 1'h0;
    assign hwif_out.base_address_register_0.base_adress.value = 28'hfff0000;
    assign hwif_out.base_ddress_register_1.region_type.value = 1'h0;
    assign hwif_out.base_ddress_register_1.locatable.value = 2'h0;
    assign hwif_out.base_ddress_register_1.prefetchable.value = 1'h0;
    assign hwif_out.base_ddress_register_1.base_adress.value = 28'hfff0000;
    // Field: pcie_config_reg.base_ddress_register_2.BAR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.base_ddress_register_2.BAR.value;
        load_next_c = '0;
        if(decoded_reg_strb.base_ddress_register_2 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.base_ddress_register_2.BAR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.base_ddress_register_2.BAR.next;
            load_next_c = '1;
        end
        field_combo.base_ddress_register_2.BAR.next = next_c;
        field_combo.base_ddress_register_2.BAR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.base_ddress_register_2.BAR.value <= 32'h20000000;
        end else begin
            if(field_combo.base_ddress_register_2.BAR.load_next) begin
                field_storage.base_ddress_register_2.BAR.value <= field_combo.base_ddress_register_2.BAR.next;
            end
        end
    end
    assign hwif_out.base_ddress_register_2.BAR.value = field_storage.base_ddress_register_2.BAR.value;
    // Field: pcie_config_reg.base_ddress_register_3.BAR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.base_ddress_register_3.BAR.value;
        load_next_c = '0;
        if(decoded_reg_strb.base_ddress_register_3 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.base_ddress_register_3.BAR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.base_ddress_register_3.BAR.next;
            load_next_c = '1;
        end
        field_combo.base_ddress_register_3.BAR.next = next_c;
        field_combo.base_ddress_register_3.BAR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.base_ddress_register_3.BAR.value <= 32'h21000000;
        end else begin
            if(field_combo.base_ddress_register_3.BAR.load_next) begin
                field_storage.base_ddress_register_3.BAR.value <= field_combo.base_ddress_register_3.BAR.next;
            end
        end
    end
    assign hwif_out.base_ddress_register_3.BAR.value = field_storage.base_ddress_register_3.BAR.value;
    // Field: pcie_config_reg.base_ddress_register_4.BAR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.base_ddress_register_4.BAR.value;
        load_next_c = '0;
        if(decoded_reg_strb.base_ddress_register_4 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.base_ddress_register_4.BAR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.base_ddress_register_4.BAR.next;
            load_next_c = '1;
        end
        field_combo.base_ddress_register_4.BAR.next = next_c;
        field_combo.base_ddress_register_4.BAR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.base_ddress_register_4.BAR.value <= 32'h30000000;
        end else begin
            if(field_combo.base_ddress_register_4.BAR.load_next) begin
                field_storage.base_ddress_register_4.BAR.value <= field_combo.base_ddress_register_4.BAR.next;
            end
        end
    end
    assign hwif_out.base_ddress_register_4.BAR.value = field_storage.base_ddress_register_4.BAR.value;
    // Field: pcie_config_reg.base_ddress_register_5.BAR
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.base_ddress_register_5.BAR.value;
        load_next_c = '0;
        if(decoded_reg_strb.base_ddress_register_5 && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.base_ddress_register_5.BAR.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.base_ddress_register_5.BAR.next;
            load_next_c = '1;
        end
        field_combo.base_ddress_register_5.BAR.next = next_c;
        field_combo.base_ddress_register_5.BAR.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.base_ddress_register_5.BAR.value <= 32'h30000000;
        end else begin
            if(field_combo.base_ddress_register_5.BAR.load_next) begin
                field_storage.base_ddress_register_5.BAR.value <= field_combo.base_ddress_register_5.BAR.next;
            end
        end
    end
    assign hwif_out.base_ddress_register_5.BAR.value = field_storage.base_ddress_register_5.BAR.value;
    // Field: pcie_config_reg.cardbus_cis_pointer.word
    always_comb begin
        automatic logic [31:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.cardbus_cis_pointer.word.value;
        load_next_c = '0;
        if(decoded_reg_strb.cardbus_cis_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.cardbus_cis_pointer.word.value & ~decoded_wr_biten[31:0]) | (decoded_wr_data[31:0] & decoded_wr_biten[31:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.cardbus_cis_pointer.word.next;
            load_next_c = '1;
        end
        field_combo.cardbus_cis_pointer.word.next = next_c;
        field_combo.cardbus_cis_pointer.word.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.cardbus_cis_pointer.word.value <= 32'h0;
        end else begin
            if(field_combo.cardbus_cis_pointer.word.load_next) begin
                field_storage.cardbus_cis_pointer.word.value <= field_combo.cardbus_cis_pointer.word.next;
            end
        end
    end
    assign hwif_out.cardbus_cis_pointer.word.value = field_storage.cardbus_cis_pointer.word.value;
    assign hwif_out.byte_offset_2C.Vendor_ID.value = 16'h0;
    assign hwif_out.byte_offset_2C.Device_ID.value = 16'h0;
    assign hwif_out.capabilities_pointer.capabilities_ptr.value = 8'h40;
    // Field: pcie_config_reg.byte_offset_3C.interrupt_line
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_3C.interrupt_line.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_3C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_3C.interrupt_line.value & ~decoded_wr_biten[7:0]) | (decoded_wr_data[7:0] & decoded_wr_biten[7:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_3C.interrupt_line.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_3C.interrupt_line.next = next_c;
        field_combo.byte_offset_3C.interrupt_line.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_3C.interrupt_line.value <= 8'h0;
        end else begin
            if(field_combo.byte_offset_3C.interrupt_line.load_next) begin
                field_storage.byte_offset_3C.interrupt_line.value <= field_combo.byte_offset_3C.interrupt_line.next;
            end
        end
    end
    assign hwif_out.byte_offset_3C.interrupt_line.value = field_storage.byte_offset_3C.interrupt_line.value;
    // Field: pcie_config_reg.byte_offset_3C.interrupt_pin
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.byte_offset_3C.interrupt_pin.value;
        load_next_c = '0;
        if(decoded_reg_strb.byte_offset_3C && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.byte_offset_3C.interrupt_pin.value & ~decoded_wr_biten[15:8]) | (decoded_wr_data[15:8] & decoded_wr_biten[15:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.byte_offset_3C.interrupt_pin.next;
            load_next_c = '1;
        end
        field_combo.byte_offset_3C.interrupt_pin.next = next_c;
        field_combo.byte_offset_3C.interrupt_pin.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.byte_offset_3C.interrupt_pin.value <= 8'h0;
        end else begin
            if(field_combo.byte_offset_3C.interrupt_pin.load_next) begin
                field_storage.byte_offset_3C.interrupt_pin.value <= field_combo.byte_offset_3C.interrupt_pin.next;
            end
        end
    end
    assign hwif_out.byte_offset_3C.interrupt_pin.value = field_storage.byte_offset_3C.interrupt_pin.value;
    assign hwif_out.byte_offset_3C.min_gnt.value = 8'h0;
    assign hwif_out.byte_offset_3C.max_lat.value = 8'h0;
    assign hwif_out.capabilities_power_mngt_pointer.capabilities_id.value = 8'h1;
    assign hwif_out.capabilities_power_mngt_pointer.next_cap_ptr.value = 8'h48;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.version
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.version.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.version.value & ~decoded_wr_biten[18:16]) | (decoded_wr_data[18:16] & decoded_wr_biten[18:16]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.version.next = next_c;
        field_combo.capabilities_power_mngt_pointer.version.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.version.load_next) begin
            field_storage.capabilities_power_mngt_pointer.version.value <= field_combo.capabilities_power_mngt_pointer.version.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.version.value = field_storage.capabilities_power_mngt_pointer.version.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.pme_clock
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.pme_clock.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.pme_clock.value & ~decoded_wr_biten[19:19]) | (decoded_wr_data[19:19] & decoded_wr_biten[19:19]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.pme_clock.next = next_c;
        field_combo.capabilities_power_mngt_pointer.pme_clock.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.pme_clock.load_next) begin
            field_storage.capabilities_power_mngt_pointer.pme_clock.value <= field_combo.capabilities_power_mngt_pointer.pme_clock.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.pme_clock.value = field_storage.capabilities_power_mngt_pointer.pme_clock.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.dev_spec_init
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.dev_spec_init.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.dev_spec_init.value & ~decoded_wr_biten[21:21]) | (decoded_wr_data[21:21] & decoded_wr_biten[21:21]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.dev_spec_init.next = next_c;
        field_combo.capabilities_power_mngt_pointer.dev_spec_init.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.dev_spec_init.load_next) begin
            field_storage.capabilities_power_mngt_pointer.dev_spec_init.value <= field_combo.capabilities_power_mngt_pointer.dev_spec_init.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.dev_spec_init.value = field_storage.capabilities_power_mngt_pointer.dev_spec_init.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.aux_current
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.aux_current.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.aux_current.value & ~decoded_wr_biten[24:22]) | (decoded_wr_data[24:22] & decoded_wr_biten[24:22]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.aux_current.next = next_c;
        field_combo.capabilities_power_mngt_pointer.aux_current.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.aux_current.load_next) begin
            field_storage.capabilities_power_mngt_pointer.aux_current.value <= field_combo.capabilities_power_mngt_pointer.aux_current.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.aux_current.value = field_storage.capabilities_power_mngt_pointer.aux_current.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.d1_support
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.d1_support.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.d1_support.value & ~decoded_wr_biten[25:25]) | (decoded_wr_data[25:25] & decoded_wr_biten[25:25]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.d1_support.next = next_c;
        field_combo.capabilities_power_mngt_pointer.d1_support.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.d1_support.load_next) begin
            field_storage.capabilities_power_mngt_pointer.d1_support.value <= field_combo.capabilities_power_mngt_pointer.d1_support.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.d1_support.value = field_storage.capabilities_power_mngt_pointer.d1_support.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.d2_support
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.d2_support.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.d2_support.value & ~decoded_wr_biten[26:26]) | (decoded_wr_data[26:26] & decoded_wr_biten[26:26]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.d2_support.next = next_c;
        field_combo.capabilities_power_mngt_pointer.d2_support.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.d2_support.load_next) begin
            field_storage.capabilities_power_mngt_pointer.d2_support.value <= field_combo.capabilities_power_mngt_pointer.d2_support.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.d2_support.value = field_storage.capabilities_power_mngt_pointer.d2_support.value;
    // Field: pcie_config_reg.capabilities_power_mngt_pointer.pme_support
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.capabilities_power_mngt_pointer.pme_support.value;
        load_next_c = '0;
        if(decoded_reg_strb.capabilities_power_mngt_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.capabilities_power_mngt_pointer.pme_support.value & ~decoded_wr_biten[31:27]) | (decoded_wr_data[31:27] & decoded_wr_biten[31:27]);
            load_next_c = '1;
        end
        field_combo.capabilities_power_mngt_pointer.pme_support.next = next_c;
        field_combo.capabilities_power_mngt_pointer.pme_support.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.capabilities_power_mngt_pointer.pme_support.load_next) begin
            field_storage.capabilities_power_mngt_pointer.pme_support.value <= field_combo.capabilities_power_mngt_pointer.pme_support.next;
        end
    end
    assign hwif_out.capabilities_power_mngt_pointer.pme_support.value = field_storage.capabilities_power_mngt_pointer.pme_support.value;
    // Field: pcie_config_reg.power_management_pointer.power_state
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.power_state.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.power_state.value & ~decoded_wr_biten[1:0]) | (decoded_wr_data[1:0] & decoded_wr_biten[1:0]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.power_state.next = next_c;
        field_combo.power_management_pointer.power_state.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.power_state.load_next) begin
            field_storage.power_management_pointer.power_state.value <= field_combo.power_management_pointer.power_state.next;
        end
    end
    assign hwif_out.power_management_pointer.power_state.value = field_storage.power_management_pointer.power_state.value;
    // Field: pcie_config_reg.power_management_pointer.pme_enable
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.pme_enable.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.pme_enable.value & ~decoded_wr_biten[3:3]) | (decoded_wr_data[3:3] & decoded_wr_biten[3:3]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.pme_enable.next = next_c;
        field_combo.power_management_pointer.pme_enable.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.pme_enable.load_next) begin
            field_storage.power_management_pointer.pme_enable.value <= field_combo.power_management_pointer.pme_enable.next;
        end
    end
    assign hwif_out.power_management_pointer.pme_enable.value = field_storage.power_management_pointer.pme_enable.value;
    // Field: pcie_config_reg.power_management_pointer.data_select
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.data_select.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.data_select.value & ~decoded_wr_biten[12:9]) | (decoded_wr_data[12:9] & decoded_wr_biten[12:9]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.data_select.next = next_c;
        field_combo.power_management_pointer.data_select.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.data_select.load_next) begin
            field_storage.power_management_pointer.data_select.value <= field_combo.power_management_pointer.data_select.next;
        end
    end
    assign hwif_out.power_management_pointer.data_select.value = field_storage.power_management_pointer.data_select.value;
    // Field: pcie_config_reg.power_management_pointer.data_scale
    always_comb begin
        automatic logic [1:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.data_scale.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.data_scale.value & ~decoded_wr_biten[14:13]) | (decoded_wr_data[14:13] & decoded_wr_biten[14:13]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.data_scale.next = next_c;
        field_combo.power_management_pointer.data_scale.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.data_scale.load_next) begin
            field_storage.power_management_pointer.data_scale.value <= field_combo.power_management_pointer.data_scale.next;
        end
    end
    assign hwif_out.power_management_pointer.data_scale.value = field_storage.power_management_pointer.data_scale.value;
    // Field: pcie_config_reg.power_management_pointer.pme_status
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.pme_status.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.pme_status.value & ~decoded_wr_biten[15:15]) | (decoded_wr_data[15:15] & decoded_wr_biten[15:15]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.pme_status.next = next_c;
        field_combo.power_management_pointer.pme_status.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.pme_status.load_next) begin
            field_storage.power_management_pointer.pme_status.value <= field_combo.power_management_pointer.pme_status.next;
        end
    end
    assign hwif_out.power_management_pointer.pme_status.value = field_storage.power_management_pointer.pme_status.value;
    // Field: pcie_config_reg.power_management_pointer.b2_b3_support
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.b2_b3_support.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.b2_b3_support.value & ~decoded_wr_biten[22:22]) | (decoded_wr_data[22:22] & decoded_wr_biten[22:22]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.b2_b3_support.next = next_c;
        field_combo.power_management_pointer.b2_b3_support.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.b2_b3_support.load_next) begin
            field_storage.power_management_pointer.b2_b3_support.value <= field_combo.power_management_pointer.b2_b3_support.next;
        end
    end
    assign hwif_out.power_management_pointer.b2_b3_support.value = field_storage.power_management_pointer.b2_b3_support.value;
    // Field: pcie_config_reg.power_management_pointer.bus_pwr_clk_ctrl_en
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.bus_pwr_clk_ctrl_en.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.bus_pwr_clk_ctrl_en.value & ~decoded_wr_biten[23:23]) | (decoded_wr_data[23:23] & decoded_wr_biten[23:23]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.bus_pwr_clk_ctrl_en.next = next_c;
        field_combo.power_management_pointer.bus_pwr_clk_ctrl_en.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.bus_pwr_clk_ctrl_en.load_next) begin
            field_storage.power_management_pointer.bus_pwr_clk_ctrl_en.value <= field_combo.power_management_pointer.bus_pwr_clk_ctrl_en.next;
        end
    end
    assign hwif_out.power_management_pointer.bus_pwr_clk_ctrl_en.value = field_storage.power_management_pointer.bus_pwr_clk_ctrl_en.value;
    // Field: pcie_config_reg.power_management_pointer.data
    always_comb begin
        automatic logic [7:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.power_management_pointer.data.value;
        load_next_c = '0;
        if(decoded_reg_strb.power_management_pointer && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.power_management_pointer.data.value & ~decoded_wr_biten[31:24]) | (decoded_wr_data[31:24] & decoded_wr_biten[31:24]);
            load_next_c = '1;
        end
        field_combo.power_management_pointer.data.next = next_c;
        field_combo.power_management_pointer.data.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(field_combo.power_management_pointer.data.load_next) begin
            field_storage.power_management_pointer.data.value <= field_combo.power_management_pointer.data.next;
        end
    end
    assign hwif_out.power_management_pointer.data.value = field_storage.power_management_pointer.data.value;
    assign hwif_out.capabilities_power_na_pointer.capabilities_id.value = 8'h10;
    assign hwif_out.capabilities_power_na_pointer.next_cap_ptr.value = 8'h0;
    assign hwif_out.capabilities_power_na_pointer.capability_version.value = 4'h2;
    assign hwif_out.capabilities_power_na_pointer.device_port_type.value = 4'h0;
    assign hwif_out.capabilities_power_na_pointer.slot_implemented.value = 1'h0;
    assign hwif_out.capabilities_power_na_pointer.interrupt_msg_number.value = 5'h0;
    assign hwif_out.capabilities_power_na_pointer.Undefined.value = 1'h0;
    assign hwif_out.capabilities_power_na_pointer.RsvdP.value = 1'h0;
    // Field: pcie_config_reg.link_control_3_register.perform_equalization
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_control_3_register.perform_equalization.value;
        load_next_c = '0;
        if(decoded_reg_strb.link_control_3_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.link_control_3_register.perform_equalization.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end
        field_combo.link_control_3_register.perform_equalization.next = next_c;
        field_combo.link_control_3_register.perform_equalization.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.link_control_3_register.perform_equalization.value <= 1'h0;
        end else begin
            if(field_combo.link_control_3_register.perform_equalization.load_next) begin
                field_storage.link_control_3_register.perform_equalization.value <= field_combo.link_control_3_register.perform_equalization.next;
            end
        end
    end
    assign hwif_out.link_control_3_register.perform_equalization.value = field_storage.link_control_3_register.perform_equalization.value;
    // Field: pcie_config_reg.link_control_3_register.link_eq_req_intr_en
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.link_control_3_register.link_eq_req_intr_en.value;
        load_next_c = '0;
        if(decoded_reg_strb.link_control_3_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.link_control_3_register.link_eq_req_intr_en.value & ~decoded_wr_biten[1:1]) | (decoded_wr_data[1:1] & decoded_wr_biten[1:1]);
            load_next_c = '1;
        end
        field_combo.link_control_3_register.link_eq_req_intr_en.next = next_c;
        field_combo.link_control_3_register.link_eq_req_intr_en.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.link_control_3_register.link_eq_req_intr_en.value <= 1'h0;
        end else begin
            if(field_combo.link_control_3_register.link_eq_req_intr_en.load_next) begin
                field_storage.link_control_3_register.link_eq_req_intr_en.value <= field_combo.link_control_3_register.link_eq_req_intr_en.next;
            end
        end
    end
    assign hwif_out.link_control_3_register.link_eq_req_intr_en.value = field_storage.link_control_3_register.link_eq_req_intr_en.value;
    // Field: pcie_config_reg.lane_error_status_register.lane_error
    always_comb begin
        automatic logic [4:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.lane_error_status_register.lane_error.value;
        load_next_c = '0;
        if(decoded_reg_strb.lane_error_status_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.lane_error_status_register.lane_error.value & ~decoded_wr_biten[4:0]) | (decoded_wr_data[4:0] & decoded_wr_biten[4:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.lane_error_status_register.lane_error.next;
            load_next_c = '1;
        end
        field_combo.lane_error_status_register.lane_error.next = next_c;
        field_combo.lane_error_status_register.lane_error.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.lane_error_status_register.lane_error.value <= 5'h0;
        end else begin
            if(field_combo.lane_error_status_register.lane_error.load_next) begin
                field_storage.lane_error_status_register.lane_error.value <= field_combo.lane_error_status_register.lane_error.next;
            end
        end
    end
    assign hwif_out.lane_error_status_register.lane_error.value = field_storage.lane_error_status_register.lane_error.value;
    // Field: pcie_config_reg.lane_eq_ctrl_register.downstream_tx_preset
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.lane_eq_ctrl_register.downstream_tx_preset.value;
        load_next_c = '0;
        if(decoded_reg_strb.lane_eq_ctrl_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.lane_eq_ctrl_register.downstream_tx_preset.value & ~decoded_wr_biten[3:0]) | (decoded_wr_data[3:0] & decoded_wr_biten[3:0]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.lane_eq_ctrl_register.downstream_tx_preset.next;
            load_next_c = '1;
        end
        field_combo.lane_eq_ctrl_register.downstream_tx_preset.next = next_c;
        field_combo.lane_eq_ctrl_register.downstream_tx_preset.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.lane_eq_ctrl_register.downstream_tx_preset.value <= 4'hf;
        end else begin
            if(field_combo.lane_eq_ctrl_register.downstream_tx_preset.load_next) begin
                field_storage.lane_eq_ctrl_register.downstream_tx_preset.value <= field_combo.lane_eq_ctrl_register.downstream_tx_preset.next;
            end
        end
    end
    assign hwif_out.lane_eq_ctrl_register.downstream_tx_preset.value = field_storage.lane_eq_ctrl_register.downstream_tx_preset.value;
    // Field: pcie_config_reg.lane_eq_ctrl_register.downstream_rx_preset_hint
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value;
        load_next_c = '0;
        if(decoded_reg_strb.lane_eq_ctrl_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value & ~decoded_wr_biten[6:4]) | (decoded_wr_data[6:4] & decoded_wr_biten[6:4]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.lane_eq_ctrl_register.downstream_rx_preset_hint.next;
            load_next_c = '1;
        end
        field_combo.lane_eq_ctrl_register.downstream_rx_preset_hint.next = next_c;
        field_combo.lane_eq_ctrl_register.downstream_rx_preset_hint.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value <= 3'h7;
        end else begin
            if(field_combo.lane_eq_ctrl_register.downstream_rx_preset_hint.load_next) begin
                field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value <= field_combo.lane_eq_ctrl_register.downstream_rx_preset_hint.next;
            end
        end
    end
    assign hwif_out.lane_eq_ctrl_register.downstream_rx_preset_hint.value = field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value;
    // Field: pcie_config_reg.lane_eq_ctrl_register.upstream_tx_preset
    always_comb begin
        automatic logic [3:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.lane_eq_ctrl_register.upstream_tx_preset.value;
        load_next_c = '0;
        if(decoded_reg_strb.lane_eq_ctrl_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.lane_eq_ctrl_register.upstream_tx_preset.value & ~decoded_wr_biten[11:8]) | (decoded_wr_data[11:8] & decoded_wr_biten[11:8]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.lane_eq_ctrl_register.upstream_tx_preset.next;
            load_next_c = '1;
        end
        field_combo.lane_eq_ctrl_register.upstream_tx_preset.next = next_c;
        field_combo.lane_eq_ctrl_register.upstream_tx_preset.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.lane_eq_ctrl_register.upstream_tx_preset.value <= 4'hf;
        end else begin
            if(field_combo.lane_eq_ctrl_register.upstream_tx_preset.load_next) begin
                field_storage.lane_eq_ctrl_register.upstream_tx_preset.value <= field_combo.lane_eq_ctrl_register.upstream_tx_preset.next;
            end
        end
    end
    assign hwif_out.lane_eq_ctrl_register.upstream_tx_preset.value = field_storage.lane_eq_ctrl_register.upstream_tx_preset.value;
    // Field: pcie_config_reg.lane_eq_ctrl_register.upstream_rx_preset_hint
    always_comb begin
        automatic logic [2:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value;
        load_next_c = '0;
        if(decoded_reg_strb.lane_eq_ctrl_register && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value & ~decoded_wr_biten[14:12]) | (decoded_wr_data[14:12] & decoded_wr_biten[14:12]);
            load_next_c = '1;
        end else begin // HW Write
            next_c = hwif_in.lane_eq_ctrl_register.upstream_rx_preset_hint.next;
            load_next_c = '1;
        end
        field_combo.lane_eq_ctrl_register.upstream_rx_preset_hint.next = next_c;
        field_combo.lane_eq_ctrl_register.upstream_rx_preset_hint.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value <= 3'h7;
        end else begin
            if(field_combo.lane_eq_ctrl_register.upstream_rx_preset_hint.load_next) begin
                field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value <= field_combo.lane_eq_ctrl_register.upstream_rx_preset_hint.next;
            end
        end
    end
    assign hwif_out.lane_eq_ctrl_register.upstream_rx_preset_hint.value = field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value;
    assign hwif_out.extended_capabilities.ext_cap.value = 32'h0;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[21];
    assign readback_array[0][15:0] = (decoded_reg_strb.byte_offset_00 && !decoded_req_is_wr) ? 16'h1234 : '0;
    assign readback_array[0][31:16] = (decoded_reg_strb.byte_offset_00 && !decoded_req_is_wr) ? 16'hff : '0;
    assign readback_array[1][1:0] = '0;
    assign readback_array[1][2:2] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.bus_master_enable.value : '0;
    assign readback_array[1][3:3] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.special_cycle_enable.value : '0;
    assign readback_array[1][4:4] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.memory_write_invalidate.value : '0;
    assign readback_array[1][5:5] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.vga_palette_snoop.value : '0;
    assign readback_array[1][6:6] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.parity_error_response.value : '0;
    assign readback_array[1][7:7] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.idsel_step_wait_cycle_control.value : '0;
    assign readback_array[1][8:8] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.SERR_Enable.value : '0;
    assign readback_array[1][9:9] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.fast_b2b_transactions_enable.value : '0;
    assign readback_array[1][10:10] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.interrupt_disable.value : '0;
    assign readback_array[1][18:11] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.rsvd.value : '0;
    assign readback_array[1][19:19] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.interrupt_status.value : '0;
    assign readback_array[1][20:20] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.capabilities_list.value : '0;
    assign readback_array[1][21:21] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.sixtysix_mhz_capable.value : '0;
    assign readback_array[1][22:22] = '0;
    assign readback_array[1][23:23] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.fast_b2b_transactions_capable.value : '0;
    assign readback_array[1][24:24] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.master_data_parity_error.value : '0;
    assign readback_array[1][26:25] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.devsel_timing.value : '0;
    assign readback_array[1][27:27] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.signaled_target_abort.value : '0;
    assign readback_array[1][28:28] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.received_target_abort.value : '0;
    assign readback_array[1][29:29] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.received_master_abort.value : '0;
    assign readback_array[1][30:30] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.signaled_system_error.value : '0;
    assign readback_array[1][31:31] = (decoded_reg_strb.byte_offset_04 && !decoded_req_is_wr) ? field_storage.byte_offset_04.detected_parity_error.value : '0;
    assign readback_array[2][7:0] = (decoded_reg_strb.byte_offset_08 && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[2][31:8] = (decoded_reg_strb.byte_offset_08 && !decoded_req_is_wr) ? 24'h0 : '0;
    assign readback_array[3][7:0] = (decoded_reg_strb.byte_offset_0C && !decoded_req_is_wr) ? field_storage.byte_offset_0C.cache_line_size_register.value : '0;
    assign readback_array[3][15:8] = (decoded_reg_strb.byte_offset_0C && !decoded_req_is_wr) ? field_storage.byte_offset_0C.latency_timer_register.value : '0;
    assign readback_array[3][23:16] = (decoded_reg_strb.byte_offset_0C && !decoded_req_is_wr) ? field_storage.byte_offset_0C.interrupt_line_register.value : '0;
    assign readback_array[3][31:24] = (decoded_reg_strb.byte_offset_0C && !decoded_req_is_wr) ? field_storage.byte_offset_0C.interrupt_pin_register.value : '0;
    assign readback_array[4][0:0] = (decoded_reg_strb.base_address_register_0 && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[4][2:1] = (decoded_reg_strb.base_address_register_0 && !decoded_req_is_wr) ? 2'h0 : '0;
    assign readback_array[4][3:3] = (decoded_reg_strb.base_address_register_0 && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[4][31:4] = (decoded_reg_strb.base_address_register_0 && !decoded_req_is_wr) ? 28'hfff0000 : '0;
    assign readback_array[5][0:0] = (decoded_reg_strb.base_ddress_register_1 && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[5][2:1] = (decoded_reg_strb.base_ddress_register_1 && !decoded_req_is_wr) ? 2'h0 : '0;
    assign readback_array[5][3:3] = (decoded_reg_strb.base_ddress_register_1 && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[5][31:4] = (decoded_reg_strb.base_ddress_register_1 && !decoded_req_is_wr) ? 28'hfff0000 : '0;
    assign readback_array[6][31:0] = (decoded_reg_strb.base_ddress_register_2 && !decoded_req_is_wr) ? field_storage.base_ddress_register_2.BAR.value : '0;
    assign readback_array[7][31:0] = (decoded_reg_strb.base_ddress_register_3 && !decoded_req_is_wr) ? field_storage.base_ddress_register_3.BAR.value : '0;
    assign readback_array[8][31:0] = (decoded_reg_strb.base_ddress_register_4 && !decoded_req_is_wr) ? field_storage.base_ddress_register_4.BAR.value : '0;
    assign readback_array[9][31:0] = (decoded_reg_strb.base_ddress_register_5 && !decoded_req_is_wr) ? field_storage.base_ddress_register_5.BAR.value : '0;
    assign readback_array[10][31:0] = (decoded_reg_strb.cardbus_cis_pointer && !decoded_req_is_wr) ? field_storage.cardbus_cis_pointer.word.value : '0;
    assign readback_array[11][15:0] = (decoded_reg_strb.byte_offset_2C && !decoded_req_is_wr) ? 16'h0 : '0;
    assign readback_array[11][31:16] = (decoded_reg_strb.byte_offset_2C && !decoded_req_is_wr) ? 16'h0 : '0;
    assign readback_array[12][7:0] = (decoded_reg_strb.capabilities_pointer && !decoded_req_is_wr) ? 8'h40 : '0;
    assign readback_array[12][31:8] = '0;
    assign readback_array[13][7:0] = (decoded_reg_strb.byte_offset_3C && !decoded_req_is_wr) ? field_storage.byte_offset_3C.interrupt_line.value : '0;
    assign readback_array[13][15:8] = (decoded_reg_strb.byte_offset_3C && !decoded_req_is_wr) ? field_storage.byte_offset_3C.interrupt_pin.value : '0;
    assign readback_array[13][23:16] = (decoded_reg_strb.byte_offset_3C && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[13][31:24] = (decoded_reg_strb.byte_offset_3C && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[14][7:0] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? 8'h1 : '0;
    assign readback_array[14][15:8] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? 8'h48 : '0;
    assign readback_array[14][18:16] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.version.value : '0;
    assign readback_array[14][19:19] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.pme_clock.value : '0;
    assign readback_array[14][20:20] = '0;
    assign readback_array[14][21:21] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.dev_spec_init.value : '0;
    assign readback_array[14][24:22] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.aux_current.value : '0;
    assign readback_array[14][25:25] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.d1_support.value : '0;
    assign readback_array[14][26:26] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.d2_support.value : '0;
    assign readback_array[14][31:27] = (decoded_reg_strb.capabilities_power_mngt_pointer && !decoded_req_is_wr) ? field_storage.capabilities_power_mngt_pointer.pme_support.value : '0;
    assign readback_array[15][1:0] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.power_state.value : '0;
    assign readback_array[15][2:2] = '0;
    assign readback_array[15][3:3] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.pme_enable.value : '0;
    assign readback_array[15][8:4] = '0;
    assign readback_array[15][12:9] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.data_select.value : '0;
    assign readback_array[15][14:13] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.data_scale.value : '0;
    assign readback_array[15][15:15] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.pme_status.value : '0;
    assign readback_array[15][21:16] = '0;
    assign readback_array[15][22:22] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.b2_b3_support.value : '0;
    assign readback_array[15][23:23] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.bus_pwr_clk_ctrl_en.value : '0;
    assign readback_array[15][31:24] = (decoded_reg_strb.power_management_pointer && !decoded_req_is_wr) ? field_storage.power_management_pointer.data.value : '0;
    assign readback_array[16][7:0] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 8'h10 : '0;
    assign readback_array[16][15:8] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 8'h0 : '0;
    assign readback_array[16][19:16] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 4'h2 : '0;
    assign readback_array[16][23:20] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 4'h0 : '0;
    assign readback_array[16][24:24] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[16][29:25] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 5'h0 : '0;
    assign readback_array[16][30:30] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[16][31:31] = (decoded_reg_strb.capabilities_power_na_pointer && !decoded_req_is_wr) ? 1'h0 : '0;
    assign readback_array[17][0:0] = (decoded_reg_strb.link_control_3_register && !decoded_req_is_wr) ? field_storage.link_control_3_register.perform_equalization.value : '0;
    assign readback_array[17][1:1] = (decoded_reg_strb.link_control_3_register && !decoded_req_is_wr) ? field_storage.link_control_3_register.link_eq_req_intr_en.value : '0;
    assign readback_array[17][31:2] = '0;
    assign readback_array[18][4:0] = (decoded_reg_strb.lane_error_status_register && !decoded_req_is_wr) ? field_storage.lane_error_status_register.lane_error.value : '0;
    assign readback_array[18][31:5] = '0;
    assign readback_array[19][3:0] = (decoded_reg_strb.lane_eq_ctrl_register && !decoded_req_is_wr) ? field_storage.lane_eq_ctrl_register.downstream_tx_preset.value : '0;
    assign readback_array[19][6:4] = (decoded_reg_strb.lane_eq_ctrl_register && !decoded_req_is_wr) ? field_storage.lane_eq_ctrl_register.downstream_rx_preset_hint.value : '0;
    assign readback_array[19][7:7] = '0;
    assign readback_array[19][11:8] = (decoded_reg_strb.lane_eq_ctrl_register && !decoded_req_is_wr) ? field_storage.lane_eq_ctrl_register.upstream_tx_preset.value : '0;
    assign readback_array[19][14:12] = (decoded_reg_strb.lane_eq_ctrl_register && !decoded_req_is_wr) ? field_storage.lane_eq_ctrl_register.upstream_rx_preset_hint.value : '0;
    assign readback_array[19][31:15] = '0;
    assign readback_array[20][31:0] = (decoded_reg_strb.extended_capabilities && !decoded_req_is_wr) ? 32'h0 : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<21; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
